class WebGL{constructor(t,e=window.innerWidth,i=window.innerHeight,r={alpha:!1}){this.canvas=t||WebGLHelper.createCanvas(e,i),this.$=this.canvas.getContext("webgl",r)}createShaderProgram(t,e){let i=this.$.createProgram(),r=(t,e)=>{let i=this.$.createShader(t);return this.$.shaderSource(i,e),this.$.compileShader(i),i};return this.$.attachShader(i,r(this.$.VERTEX_SHADER,t)),this.$.attachShader(i,r(this.$.FRAGMENT_SHADER,e)),this.$.linkProgram(i),this.$.useProgram(i),i}initializeBuffer(t,e){for(let i of t){let t;if(i instanceof Float32Array)t=this.$.ARRAY_BUFFER;else{if(!(i instanceof Uint8Array||i instanceof Uint16Array))throw new TypeError("Unsupported typed array type");t=this.$.ELEMENT_ARRAY_BUFFER}!0===e?(this.$.bindBuffer(t,this.$.createBuffer()),this.$.bufferData(t,i,this.$.STATIC_DRAW)):this.$.bufferData(t,i,this.$.STATIC_DRAW)}}setAttribute(t,e,i){let r=e[0].BYTES_PER_ELEMENT*Object.values(i).reduce((t,e)=>t+e);for(let s in i){let a=this.$.getAttribLocation(t,s),h=0;"a_TextureCoords"==s&&(h=e[0].BYTES_PER_ELEMENT*i.a_Position),this.$.vertexAttribPointer(a,i[s],this.$.FLOAT,!1,r,h),this.$.enableVertexAttribArray(a)}}setUniformValue(t,e){for(let i in e){let r=this.$.getUniformLocation(t,i);switch(e[i].type){case"bool":case"int":this.$.uniform1i(r,e[i].value);break;case"float":this.$.uniform1f(r,e[i].value);break;case"vec2":this.$.uniform2fv(r,e[i].value);break;case"vec3":this.$.uniform3fv(r,e[i].value);break;case"vec4":this.$.uniform4fv(r,e[i].value);break;case"mat4":this.$.uniformMatrix4fv(r,!1,e[i].value)}}}createAndSetupTexture(t){let e=this.$.createTexture();if(this.$.bindTexture(this.$.TEXTURE_2D,e),t instanceof Uint8Array)this.$.texImage2D(this.$.TEXTURE_2D,0,this.$.RGBA,1,1,0,this.$.RGBA,this.$.UNSIGNED_BYTE,t);else{if(!(t instanceof ImageBitmap||t instanceof Object))throw new TypeError("Unsupported texture source type");WebGLHelper.isDedgeeTwo(t.width||t.clientWidth)||WebGLHelper.isDedgeeTwo(t.height||t.clientHeight)||(this.$.texParameteri(this.$.TEXTURE_2D,this.$.TEXTURE_WRAP_S,this.$.CLAMP_TO_EDGE),this.$.texParameteri(this.$.TEXTURE_2D,this.$.TEXTURE_WRAP_T,this.$.CLAMP_TO_EDGE)),this.$.pixelStorei(this.$.UNPACK_FLIP_Y_WEBGL,!0),this.$.texParameteri(this.$.TEXTURE_2D,this.$.TEXTURE_MIN_FILTER,this.$.LINEAR),this.$.texImage2D(this.$.TEXTURE_2D,0,this.$.RGBA,this.$.RGBA,this.$.UNSIGNED_BYTE,t)}return e}updateTexture(t,e){if(this.$.bindTexture(this.$.TEXTURE_2D,t),e instanceof Uint8Array)this.$.texImage2D(this.$.TEXTURE_2D,0,this.$.RGBA,1,1,0,this.$.RGBA,this.$.UNSIGNED_BYTE,e);else{if(!(e instanceof ImageBitmap||e instanceof Object))throw new TypeError("Unsupported texture source type");this.$.texImage2D(this.$.TEXTURE_2D,0,this.$.RGBA,this.$.RGBA,this.$.UNSIGNED_BYTE,e)}}defineTextureSlot(t,e,i){this.$.bindTexture(this.$.TEXTURE_2D,i),this.$.activeTexture(this.$.TEXTURE0+Object.values(e)[0].value),this.setUniformValue(t,e)}prepareCanvas(t,e){if(t){for(let e in t)if(t[e]<0||t[e]>255)throw new Error("Ð¡olor value is incorrect");this.$.clearColor(1/255*t.r,1/255*t.g,1/255*t.b,t.a)}e&&this.$.viewport(0,0,this.canvas.width,this.canvas.height),this.$.clear(this.$.COLOR_BUFFER_BIT)}drawFrame(t,e,i,r){let s=e[1]??e[0];if(this.setUniformValue(t,i),r&&this.$.bindTexture(this.$.TEXTURE_2D,r),s instanceof Float32Array)this.$.drawArrays(this.$.TRIANGLES,0,s.length/s.size);else{if(!(s instanceof Uint8Array||s instanceof Uint16Array))throw new TypeError("Unsupported typed array type");this.$.drawElements(this.$.TRIANGLES,s.length,this.$.UNSIGNED_SHORT,0)}}}class WebGLGeometry{static createPlane(t,e,i,r,s,a,h,n){let o,$,E,c,[T,l]=WebGLHelper.convertCoords(t,e,i),[u,f]=WebGLHelper.convertCoords(t,t.clientWidth,t.clientHeight),A=h?l-f/2:l/2,R=n?u/2:T/2,d=[],_=[];o=(r=r<1?1:r)+1,$=(s=s<1?1:s)+1,a&&(E=1/r,c=1/s);for(let t=0;t<$;t++)for(let e=0;e<o;e++)if(d.push(T/r*e-R,l/s*t-A),a&&d.push(E*e,c*t),e<r&&t<s){let i=e+o*t,r=e+o*(t+1),s=e+1+o*(t+1),a=e+1+o*t;_.push(i,r,a,r,s,a)}return[new Float32Array(d),new Uint16Array(_)]}}class WebGLHelper{static createCanvas(t,e){let i=document.createElement("canvas");return i.id="canvas_webgl",i.setAttribute("width",t),i.setAttribute("height",e),i}static isDedgeeTwo(t){return 0==(t&t-1)}static convertCoords(t,e,i){return[e/((t?t.width:window.innerWidth)/2),i/((t?t.height:window.innerHeight)/2)]}}